<!DOCTYPE html>
<html lang="en">
<head>
  <title>Manticore Operating System</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Manticore operating system">
  <meta name="keywords" content="manticore, operating system">
  <link rel="stylesheet" href="https://unpkg.com/spectre.css/dist/spectre.min.css">
  <style>
    body {
      padding: 1em;
      margin: 0 auto;
    }

    @media screen and (min-width: 1025px) {
      body {
        width: 50%;
      }
    }

    ul {
      list-style: outside;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="columns">
      <div class="column col12">
        <header class="navbar">
          <div class="navbar-section">
            <a href="https://manticoreos.io/" class="navbar-brand">Home</a>
          </div>
          <div class="navbar-section">
            <a href="#features" class="btn btn-link">Features</a>
            <a href="#publications" class="btn btn-link">Publications</a>
            <a href="https://github.com/manticoreos/manticore" class="btn btn-link">GitHub</a>
          </div>
        </header>
      </div>
    </div>

    <div class="columns">
      <div class="column col12">
        <p align="center">
          <img src="img/manticore.png" alt="Manticore Operating System" style="max-width: 100%">
        </p>

        <p>
	  Manticore is a research operating system, written in Rust, with the aim of exploring the parakernel OS architecture.

        <p>
	  The OS is increasingly a bottleneck for server applications that want to take maximum advantage of the hardware. Many traditional kernel interfaces (such as in POSIX) were designed when I/O was significantly slower than the CPU.
	  However, today I/O is getting faster, but single-threaded CPU performance has stagnated.
	  For example, a 40 GbE NIC can receive a cache-line sized packet faster than the CPU can access its last-level cache (LLC), which makes it tricky for an OS to keep up with packets arriving from the network.
	  Similarly, non-volatile memory (NVM) access speed is getting closer to DRAM speeds, which challenges OS abstractions for storage.

        <p>
	  To address this OS bottleneck, server applications are increasingly adopting kernel-bypass techniques.
	  For example, the Seastar framework is an OS implemented in userspace, which implements its own CPU and I/O scheduler, and bypasses the Linux kernel as much as it can.
	  Parakernel is an OS architecture that eliminates many OS abstractions (similar to exokernels) and partitions hardware resources (similar to multikernels) to facilitate high-performance server application with increased application-level parallelism and predictable tail latency.
	</p>

        <h2 id="features">Features</h2>
        <p>
          <ul>
            <li>Process scheduling (no kernel threads)</li>
            <li>Hardware resource partitioning</li>
            <li>Virtual memory (no demand paging)</li>
            <li>Kernel-bypass by default</li>
            <li>Non-blocking OS system calls</li>
            <li>ELF executable support</li>
          </ul>
        </p>

        <h2 id="publications">Publications</h2>
        <p>
          <ul>
            <li>Pekka Enberg, Ashwin Rao, and Sasu Tarkoma.
	      <b>I/O Is Faster Than the CPU: Let's Partition Resources and Eliminate (Most) OS Abstractions</b>.
	      In <i>Proceedings of the Workshop on Hot Topics in Operating Systems (HotOS '19)</i>, Bertinoro, Italy, May 2019. [ <a href="http://penberg.org/parakernel-hotos19.pdf">PDF</a> ]
	    </li>
          </ul>
        </p>
      </div>
    </div>
  </div>
</body>
</html>
